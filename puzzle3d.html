<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>ECOLUD - Puzzle 3D</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="game.css" />
  <style>
    html,
    body {
      height: 100%;
    }
    body.page-puzzle3d {
      margin: 0;
      min-height: 100vh;
      font-family: 'Poppins', sans-serif;
      color: #123b3d;
      background: linear-gradient(180deg, #e9f9ff 0%, #f6fff9 100%);
      display: flex;
      flex-direction: column;
      opacity: 1 !important;
    }
    .puzzle3d-main {
      flex: 1;
      padding: clamp(32px, 6vw, 72px) clamp(24px, 5vw, 80px);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .puzzle3d-shell {
      width: min(1200px, 100%);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
      gap: clamp(32px, 4vw, 56px);
    }
    .puzzle-stage {
      position: relative;
      width: 720px;
      height: 960px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
    }
    #app {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .puzzle-frame {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 36px;
      background: radial-gradient(circle at 18% 18%, rgba(21, 58, 94, 0.95), rgba(7, 20, 36, 0.98));
      box-shadow: 0 40px 120px rgba(8, 30, 58, 0.28), inset 0 0 0 1px rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .puzzle-frame::before {
      content: '';
      position: absolute;
      inset: -12px;
      border-radius: 44px;
      background: linear-gradient(145deg, rgba(17, 42, 70, 0.6), rgba(8, 18, 34, 0.75));
      border: 1px solid rgba(255, 255, 255, 0.14);
      pointer-events: none;
      z-index: -1;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
      background: #0c1c2d;
      border-radius: 28px;
      box-shadow: inset 0 0 26px rgba(0, 0, 0, 0.55);
    }
    .hud {
      position: absolute;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(10, 25, 43, 0.76);
      border: 1px solid rgba(255, 255, 255, 0.14);
      padding: 10px 14px;
      border-radius: 999px;
      backdrop-filter: blur(14px);
      font-size: 13px;
      line-height: 1.4;
      display: flex;
      gap: 10px;
      align-items: center;
      color: #f0f6fb;
      box-shadow: 0 14px 40px rgba(5, 20, 40, 0.35);
    }
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.08);
    }
    .hud .btn {
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(38, 98, 157, 0.95);
      color: #ffffff;
      padding: 8px 16px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .hud .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(15, 76, 129, 0.35);
    }
    .hud label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #f0f6fb;
      font-weight: 500;
    }
    .hud input[type='checkbox'] {
      width: 18px;
      height: 18px;
      accent-color: #00c4af;
    }
    .status-overlay {
      position: absolute;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      width: min(420px, calc(100% - 48px));
      background: rgba(9, 21, 39, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 18px;
      padding: 14px 20px;
      text-align: center;
      font-size: 15px;
      line-height: 1.5;
      color: #eef6ff;
      backdrop-filter: blur(12px);
      box-shadow: 0 24px 80px rgba(6, 20, 38, 0.45);
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }
    .status-overlay.hidden {
      opacity: 0;
      transform: translate(-50%, 12px);
    }
    .puzzle3d-sidebar {
      width: min(360px, 100%);
      background: rgba(255, 255, 255, 0.92);
      border-radius: 28px;
      padding: clamp(20px, 4vw, 32px);
      box-shadow: 0 26px 52px rgba(0, 83, 70, 0.14);
      border: 1px solid rgba(15, 104, 94, 0.08);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .puzzle3d-sidebar h2 {
      font-size: clamp(20px, 3vw, 26px);
      margin: 0;
      color: #0e5862;
    }
    .puzzle3d-sidebar p {
      margin: 0;
      color: #45666d;
      line-height: 1.55;
    }
    .puzzle3d-sidebar ul {
      margin: 0;
      padding: 0 0 0 18px;
      display: grid;
      gap: 8px;
      color: #2f5d64;
    }
    .puzzle3d-sidebar .cta {
      margin-top: auto;
      display: inline-flex;
      align-self: flex-start;
      background: linear-gradient(135deg, #00c4af, #009682);
      color: #ffffff;
      padding: 10px 20px;
      border-radius: 999px;
      text-decoration: none;
      font-weight: 600;
      box-shadow: 0 16px 32px rgba(0, 148, 129, 0.25);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .puzzle3d-sidebar .cta:hover {
      transform: translateY(-1px);
      box-shadow: 0 20px 36px rgba(0, 148, 129, 0.28);
    }
    @media (max-width: 1280px) {
      .puzzle-stage {
        transform: scale(0.9);
        transform-origin: top center;
      }
    }
    @media (max-width: 1024px) {
      .puzzle-stage {
        transform: scale(0.8);
      }
    }
    @media (max-width: 860px) {
      .puzzle-stage {
        transform: scale(0.72);
      }
    }
    @media (max-width: 720px) {
      .puzzle-stage {
        transform: scale(0.62);
      }
      .puzzle3d-sidebar {
        width: 100%;
      }
    }
  </style>
  <script type="importmap">
    { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    } }
  </script>
</head>
<body class="page-puzzle3d">
  <header class="site-header" id="siteHeader">
    <a href="index.html" class="site-logo" aria-label="ECOLUD accueil">
      <span aria-hidden="true">&#127793;</span>
      ECOLUD
    </a>
    <nav class="site-nav" aria-label="Navigation principale">
      <a href="index.html#top" data-i18n="nav-home">Accueil</a>
      <a href="index.html#shop" data-i18n="nav-shop">Boutique</a>
      <a href="game.html" class="active" data-i18n="nav-play">Jouer</a>
      <a href="index.html#experience" data-i18n="nav-experience">Exp&eacute;rience</a>
      <a href="contact.html" data-i18n="nav-contact">Contact</a>
    </nav>
    <div class="header-actions">
      <div class="nav-session" id="navSession">
        <div class="player-badge user-info hidden" id="navPlayerBadge" aria-live="polite">
          <img id="navPlayerAvatar" src="" alt="Avatar du joueur" />
          <span id="navPlayerName"></span>
        </div>
        <button
          type="button"
          class="btn btn-ghost nav-change hidden"
          id="navChangeProfile"
          data-change-profile
          data-profile-target="choose.html"
          data-profile-mode="reset"
          data-i18n="change-profile"
        >
          Changer de profil
        </button>
      </div>
      <button type="button" class="btn btn-primary hidden" id="navPlayButton" data-i18n="index-play">
        Connexion / Jouer
      </button>
      <div class="lang-toggle" role="group" aria-label="Changer de langue">
        <button type="button" class="active" data-lang-btn data-lang="fr">FR</button>
        <button type="button" data-lang-btn data-lang="en">EN</button>
        <button type="button" data-lang-btn data-lang="es">ES</button>
      </div>
      <a href="index.html" class="btn btn-ghost" data-i18n="nav-back">Retour accueil</a>
    </div>
  </header>
  <main class="puzzle3d-main" data-i18n-container>
    <section class="puzzle3d-shell">
      <div class="puzzle-stage">
        <div class="hud">
          <div class="badge">Difficulte: <span id="difficultyLabel">Moyen</span></div>
          <div class="badge" id="groupInfo">Bloc: 1 piece</div>
          <div class="badge" id="placedInfo">0 placees</div>
          <label>
            <input type="checkbox" id="lockAfterMerge" checked /> Verrouiller blocs assembles
          </label>
          <button class="btn" id="resetBtn">Reinitialiser</button>
        </div>
        <div id="app">
          <div class="puzzle-frame" id="puzzleFrame"></div>
        </div>
        <div id="statusOverlay" class="status-overlay">Chargement du puzzle 3D...</div>
      </div>
      <aside class="puzzle3d-sidebar">
        <h2>Protect the Oceans</h2>
        <p>
          Assemble le puzzle magn&eacute;tique ECOLUD et d&eacute;couvre les secrets du r&eacute;cif en 3D. Chaque bloc
          plac&eacute; t&rsquo;approche de la restauration de nos oc&eacute;ans.
        </p>
        <ul>
          <li>Fais glisser les pi&egrave;ces pour les positionner et les aimanter &agrave; leurs voisines.</li>
          <li>Active le verrouillage pour souder d&eacute;finitivement les blocs assembl&eacute;s.</li>
          <li>Le bouton &laquo;&nbsp;R&eacute;initialiser&nbsp;&raquo; redistribue les pi&egrave;ces autour de la zone de jeu.</li>
        </ul>
        <p>
          Tu peux revenir aux missions ECOLUD &agrave; tout moment pour suivre ta progression et challenger ton &eacute;quipe.
        </p>
        <a class="cta" href="game.html">Retour aux missions</a>
      </aside>
    </section>
  </main>
  <audio id="snapSound" src="assets/puzzle3d/click.mp3" preload="auto"></audio>
  <script src="app.js" defer></script>
  <script>
    window.addEventListener('load', function () {
      document.body.classList.add('loaded');
    });
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    // ========= CONFIG (4:3 PORTRAIT, 2D STRICT) ==============================
    const params = new URLSearchParams(window.location.search);
    const difficultyKey = (params.get('difficulty') || 'medium').toLowerCase();
    const difficultyLabels = { easy: 'Facile', medium: 'Moyen', hard: 'Difficile' };
    const difficultyLabelElement = document.getElementById('difficultyLabel');
    if (difficultyLabelElement) {
      difficultyLabelElement.textContent = difficultyLabels[difficultyKey] || difficultyLabels.medium;
    }
    const MODEL_URL = 'assets/puzzle3d/puzzle_50_scattered.glb';   // fichier local
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;              // 4:3 portrait
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;
    // — Déplacement fluide & aimantation
    const POS_EPS = 0.003;
    const LERP_DRAG = 0.35;        // lissage du drag
    const LERP_SNAP = 0.5;         // accélération vers la cible
    // — Seuils d'aimantation (2D)
    const SNAP_GRID = 0.18;        // capture sur la cible absolue
    const SNAP_NEIGH_EAGER = 0.14; // aimantation immédiate (voisin exact)
    const SNAP_NEIGH = 0.2;        // voisinage "proche" (drag continu)
    // — Hystérésis (bande collante pour éviter le papillonnement)
    const STICKY_BAND = 0.25;
    // Anti-chevauchement (distance minimale entre centres de blocs)
    const MIN_CENTER_DIST = Math.min(CELL_W, CELL_H)*0.24;
    // Bornes XY de l'aire de jeu
    const BOUNDS_MARGIN = Math.max(PUZZLE_W, PUZZLE_H) * 0.8;
    // ========= SCÈNE =========================================================
    const app = document.getElementById('app');
    const frameEl = document.getElementById('puzzleFrame');
    const scene = new THREE.Scene(); scene.background = null;
    const CANVAS_W = 720;
    const CANVAS_H = 960;
    const aspectPuzzle = CANVAS_W / CANVAS_H;
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x0d1828, 0);
    renderer.setSize(CANVAS_W, CANVAS_H, false);
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    (frameEl || app).appendChild(renderer.domElement);
    if (frameEl) {
      frameEl.style.width = `${CANVAS_W}px`;
      frameEl.style.height = `${CANVAS_H}px`;
    }
    const viewH = PUZZLE_H;
    const viewW = viewH * aspectPuzzle;
    const camera = new THREE.OrthographicCamera(
      -viewW/2, viewW/2, viewH/2, -viewH/2, -10, 10
    );
    camera.position.set(0,0,5); camera.lookAt(0,0,0);
    scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.8));
    const dl = new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(2,3,4); scene.add(dl);
    // Raycast & pointeur
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const tempVec = new THREE.Vector3();
    const puzzleRoot = new THREE.Group(); scene.add(puzzleRoot);
    const pickableMeshes = [];
    const entriesByName = new Map();
    const entries = [];
    const outlineColor = 0xd9c29c;
    const createOutlinesForBlock = (block) => {
      const outlines = [];
      const originals = [];
      block.traverse(child => {
        if (child.isMesh && !(child.userData && child.userData.outlineHelper)) {
          originals.push(child);
        }
      });
      originals.forEach(child => {
        const outlineMat = new THREE.MeshBasicMaterial({
          color: outlineColor,
          side: THREE.BackSide,
          transparent: true,
          opacity: 0.85,
          depthWrite: false
        });
        const outline = new THREE.Mesh(child.geometry, outlineMat);
        outline.scale.multiplyScalar(1.012);
        outline.position.set(0, 0, -0.002);
        outline.renderOrder = child.renderOrder - 1;
        outline.userData = { outlineHelper: true };
        child.add(outline);
        outlines.push(outline);
      });
      return outlines;
    };
    const statusOverlay = document.getElementById('statusOverlay');
    let statusTimer = null;
    const showStatus = (message, { hideAfter } = {}) => {
      if (!statusOverlay) return;
      statusOverlay.textContent = message;
      statusOverlay.classList.remove('hidden');
      if (statusTimer) {
        clearTimeout(statusTimer);
        statusTimer = null;
      }
      if (typeof hideAfter === 'number' && hideAfter > 0) {
        statusTimer = setTimeout(() => {
          statusOverlay.classList.add('hidden');
          statusTimer = null;
        }, hideAfter);
      }
    };
    const hideStatus = () => {
      if (!statusOverlay) return;
      statusOverlay.classList.add('hidden');
      if (statusTimer) {
        clearTimeout(statusTimer);
        statusTimer = null;
      }
    };
    const x0 = -PUZZLE_W/2 + CELL_W/2;
    const y0 =  PUZZLE_H/2 - CELL_H/2;
    const targetOf = (rc)=> new THREE.Vector3(x0 + rc.c*CELL_W, y0 - rc.r*CELL_H, 0);
    const setAllToTargets = () => {
      for (const entry of entries) {
        entry.group.position.copy(entry.target);
        entry.group.position.z = 0;
      }
    };
    const recenterTargets = () => {
      setAllToTargets();
      puzzleRoot.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(puzzleRoot);
      const center = bbox.getCenter(new THREE.Vector3());
      if (!Number.isFinite(center.x) || !Number.isFinite(center.y)) return;
      if (Math.abs(center.x) < 1e-3 && Math.abs(center.y) < 1e-3) return;
      for (const entry of entries) {
        entry.target.sub(center);
        entry.group.position.sub(center);
        entry.group.position.z = 0;
      }
    };
    // ======== UTILITAIRES MANQUANTS (restaurés) ==============================
    function forcePlanarZ(root, z=0){
      root.traverse(o=>{ if(o.position) o.position.z = z; });
    }
    function reparentKeepWorld(child, newParent){
      const wp = new THREE.Vector3(); child.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); child.getWorldQuaternion(wq);
      newParent.add(child);
      child.position.copy(newParent.worldToLocal(wp));
      const inv = newParent.getWorldQuaternion(new THREE.Quaternion()).invert();
      child.quaternion.copy(inv.multiply(wq));
      child.scale.set(1,1,1);
    }
    // ======== CHARGEMENT GLB ================================================
    const loader = new GLTFLoader();
    loader.load(MODEL_URL, (gltf)=>{
      const root = gltf.scene;
      root.traverse(o=>{
        if(o.isMesh){
          pickableMeshes.push(o);
          const mats = Array.isArray(o.material)? o.material : [o.material];
          for(const m of mats){ if(m){ m.side = THREE.FrontSide; } }
        }
      });
      orientFaceOn(root);
      for(const rNode of uniqueRootsUnder(root)){
        const rc = parseRC(rNode.name) || {r:0,c:0};
        const block = reparentAsBlock(rNode, puzzleRoot);
        block.userData = block.userData || {};
        block.userData.placed = false;
        block.position.z = 0.05;
        const outlines = createOutlinesForBlock(block);
        const entry = {
          group:block,
          mesh:rNode,
          rc,
          target:targetOf(rc),
          placed:false,
          stickyTo:null,
          outlineMeshes: outlines,
          dragOrigin: new THREE.Vector3(),
          dragTravel: 0
        };
        entries.push(entry);
        entriesByName.set(`r${rc.r}_c${rc.c}`, entry);
      }
      forcePlanarZ(puzzleRoot, 0);
      recenterTargets();
      scatterEntries(0.3);
      updateHUD();
      render();
      showStatus('Puzzle pret : fais glisser les pieces !', { hideAfter: 3200 });
    }, undefined, err=>{
      console.error(err);
      showStatus('Impossible de charger le puzzle 3D. Verifie que le projet est servi depuis un serveur local et que le fichier assets/puzzle3d/puzzle_50_scattered.glb est accessible.');
    });
    function orientFaceOn(root){
      root.rotation.set(0,0,0);
      root.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(root);
      if(bbox.getSize(new THREE.Vector3()).z > 0.2){
        root.rotation.x = Math.PI/2; // remet à plat si import en "tranche"
        root.updateMatrixWorld(true);
      }
    }
    function uniqueRootsUnder(root){
      const set = new Set();
      for(const m of pickableMeshes){
        let n=m; while(n.parent && n.parent!==root) n=n.parent;
        set.add(n);
      }
      return [...set];
    }
    function parseRC(name=''){
      const m = /r(\d+)_c(\d+)/i.exec(name);
      return m? {r:+m[1], c:+m[2]} : null;
    }
    function reparentAsBlock(node, parent){
      const block = new THREE.Group();
      parent.add(block);
      node.updateMatrixWorld(true);
      const wp = new THREE.Vector3(); node.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); node.getWorldQuaternion(wq);
      block.position.copy(wp); block.quaternion.copy(wq); block.scale.set(1,1,1);
      block.add(node);
      node.position.set(0,0,0); node.quaternion.identity(); node.scale.set(1,1,1);
      return block;
    }
    // ======== DRAG/SNAP/COLLISION (2D) =======================================
    let dragging = null;
    let dragOffset = new THREE.Vector3(); // offset clic→centre
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0
    function setPointer(e){
      const p = e.touches?.[0] || e.changedTouches?.[0] || e;
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((p.clientX-rect.left)/rect.width)*2-1;
      pointer.y=-((p.clientY-rect.top)/rect.height)*2+1;
      return p;
    }
    function rayFromPointer(){
      const r = new THREE.Ray();
      const origin = new THREE.Vector3(pointer.x, pointer.y, 0).unproject(camera);
      const dir = new THREE.Vector3(0,0,-1).transformDirection(camera.matrixWorld);
      r.origin.copy(origin); r.direction.copy(dir);
      return r;
    }
    function intersectPickable(){
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pickableMeshes, true);
      for(const h of hits){
        const e = entryFromObject(h.object);
        if(e) return {entry:e, hitPoint:h.point};
      }
      return null;
    }
    function entryFromObject(obj){
      let n = obj;
      while(n && n.parent && n.parent!==puzzleRoot) n = n.parent;
      if(!n) return null;
      return entries.find(e=>e.group===n) || null;
    }
    function findBlock(g){
      let n=g; while(n.parent && n.parent!==puzzleRoot) n=n.parent;
      return n||g;
    }
    const refreshBlockVisual = (block) => {
      if (!block) return;
      const members = entries.filter(e => findBlock(e.group) === block);
      const allPlaced = members.every(e => e.placed);
      block.userData = block.userData || {};
      block.userData.placed = allPlaced;
      block.position.z = allPlaced ? -0.25 : 0.05;
      members.forEach(mem => {
        if (mem.outlineMeshes) {
          mem.outlineMeshes.forEach(outline => {
            outline.visible = !mem.placed;
          });
        }
      });
    };
        const setEntryPlaced = (entry, placed) => {
      entry.placed = placed;
      entry.stickyTo = null;
      const block = findBlock(entry.group);
      if(block){
        block.userData = block.userData || {};
        block.userData.dragging = false;
        refreshBlockVisual(block);
        if (entry.dragOrigin) {
          entry.dragOrigin.copy(block.position);
        }
      }
      entry.dragTravel = 0;
    };
    function clampInBounds(v){
      const halfW = PUZZLE_W/2 + BOUNDS_MARGIN;
      const halfH = PUZZLE_H/2 + BOUNDS_MARGIN;
      v.x = Math.max(-halfW, Math.min(halfW, v.x));
      v.y = Math.max(-halfH, Math.min(halfH, v.y));
      v.z = 0;
    }
    function neighRCs(rc){
      const list=[];
      if(rc.r>0)      list.push({r:rc.r-1,c:rc.c, dx:0,        dy:+CELL_H});
      if(rc.r<ROWS-1) list.push({r:rc.r+1,c:rc.c, dx:0,        dy:-CELL_H});
      if(rc.c>0)      list.push({r:rc.r,  c:rc.c-1, dx:-CELL_W,dy:0});
      if(rc.c<COLS-1) list.push({r:rc.r,  c:rc.c+1, dx:+CELL_W,dy:0});
      return list;
    }
    function isIntendedNeighbor(entry, other){
      const rc = entry.rc;
      return neighRCs(rc).some(n => `r${n.r}_c${n.c}` === `r${other.rc.r}_c${other.rc.c}`);
    }
    // — anti-chevauchement (résolution douce)
    function resolveCollisionsFor(entry, ignoreForSnap=false){
      const A = findBlock(entry.group);
      const posA = A.position;
      for(const e of entries){
        const B = findBlock(e.group);
        if(B===A) continue;
        if(!ignoreForSnap && isIntendedNeighbor(entry, e)) continue; // pas de répulsion pour le voisin logique
        const posB = B.position;
        const delta = new THREE.Vector3().subVectors(posA, posB);
        const dist = delta.length();
        if(dist < MIN_CENTER_DIST){
          if(dist < 1e-6){
            delta.set(Math.random()-0.5, Math.random()-0.5, 0).normalize().multiplyScalar(MIN_CENTER_DIST);
          }else{
            delta.multiplyScalar((MIN_CENTER_DIST - dist)/dist);
          }
          posA.add(delta);
          clampInBounds(posA);
        }
      }
    }
    // — SNAP GRILLE & VOISINS
    const audioEl = document.getElementById('snapSound');
    function playSnap(){
      if(!audioEl) return;
      try{
        audioEl.currentTime = 0;
        const p = audioEl.play();
        if(p && typeof p.catch === 'function'){ p.catch(()=>{}); }
      }catch{}
    }
    function trySnapGrid(entry, final){
      const d = entry.group.position.distanceTo(entry.target);
      if(d > SNAP_GRID) return false;
      const aim = entry.target.clone();
      if(final || d < SNAP_NEIGH_EAGER){
        entry.group.position.copy(aim);
      } else {
        entry.group.position.lerp(aim, LERP_SNAP);
      }
      entry.group.position.z = 0;
      const ok = entry.group.position.distanceTo(aim) < (final? 2*POS_EPS : 0.02);
      if(ok){
        entry.group.position.copy(aim);
        entry.group.position.z = 0;
        setEntryPlaced(entry, true);
        forcePlanarZ(findBlock(entry.group), 0);
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }
    function trySnapNeighbors(entry, final){
      const rc = entry.rc;
      const posA = entry.group.position;
      // garder l'accroche si déjà collé à un voisin
      if(entry.stickyTo){
        const { nbKey, desired } = entry.stickyTo;
        const nb = entriesByName.get(nbKey);
        if(nb){
          const posB = nb.group.position;
          const dist = new THREE.Vector3().subVectors(posB, posA).sub(desired).length();
          if(dist < STICKY_BAND){
            const newPosA = new THREE.Vector3().subVectors(posB, desired);
            if(final || dist < SNAP_NEIGH_EAGER){ posA.copy(newPosA);} else { posA.lerp(newPosA, LERP_SNAP); }
            posA.z = 0;
            return true;
          } else {
            entry.stickyTo = null;
          }
        } else {
          entry.stickyTo = null;
        }
      }
      // choisir le meilleur voisin
      let best = null;
      for(const n of neighRCs(rc)){
        const nb = entriesByName.get(`r${n.r}_c${n.c}`);
        if(!nb) continue;
        const blockA = findBlock(entry.group);
        const blockB = findBlock(nb.group);
        if(blockA===blockB) continue;
        const posB = nb.group.position;
        const desired = new THREE.Vector3(n.dx, n.dy, 0);
        const dist = new THREE.Vector3().subVectors(posB, posA).sub(desired).length();
        if(best===null || dist < best.dist){ best = { nb, desired, dist, nbKey:`r${n.r}_c${n.c}` }; }
      }
      if(!best) return false;
      const eager = best.dist < SNAP_NEIGH_EAGER;
      const near  = best.dist < SNAP_NEIGH;
      if(eager || near){
        const blockA = findBlock(entry.group);
        const blockB = findBlock(best.nb.group);
        const newPosA = new THREE.Vector3().subVectors(best.nb.group.position, best.desired);
        if(eager || final){ posA.copy(newPosA);} else { posA.lerp(newPosA, LERP_SNAP); }
        posA.z = 0;
        mergeBlocks(blockA, blockB);
        forcePlanarZ(findBlock(entry.group), 0);
        entry.stickyTo = { nbKey: best.nbKey, desired: best.desired.clone() };
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }
    function mergeBlocks(A, B){
      if(A===B) return;
      const parent = new THREE.Group(); puzzleRoot.add(parent);
      const pa = new THREE.Vector3(); A.getWorldPosition(pa);
      const pb = new THREE.Vector3(); B.getWorldPosition(pb);
      parent.position.copy(pa.add(pb).multiplyScalar(0.5));
      reparentKeepWorld(A, parent);
      reparentKeepWorld(B, parent);
      forcePlanarZ(parent, 0);
      // Bloc indissociable : on le marque "locked" si l’option est cochée
      parent.userData.locked = document.getElementById('lockAfterMerge').checked;
      // Rattacher les entrées au nouveau parent
      const affected = [];
      for(const e of entries){
        const r = findBlock(e.group);
        if(r===A || r===B || r===parent){
          e.group = parent;
          affected.push(e);
        }
      }
      affected.forEach(e => setEntryPlaced(e, true));
      refreshBlockVisual(parent);
    }
    // ======== INPUTS =========================================================
    function pointerDown(e){
      e.preventDefault();
      setPointer(e);
      const pick = intersectPickable();
      if(!pick) return;
      const { entry, hitPoint } = pick;
      const block = findBlock(entry.group);
      if(block.userData && block.userData.locked) return;
      if(entry.placed || (block.userData && block.userData.placed)) return;
      puzzleRoot.attach(block);
      block.position.z = 0.12;
      block.userData = block.userData || {};
      block.userData.dragging = true;
      dragging = entry;
      const center = block.position.clone();
      dragOffset.copy(hitPoint.clone().sub(center));
      dragOffset.z = 0;
    }
    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();
      setPointer(e);
      const ray = rayFromPointer();
      const hit = new THREE.Vector3();
      if(!ray.intersectPlane(dragPlane, hit)) return;
      const pos = dragging.group.position;
      const target = hit.sub(dragOffset);
      pos.lerp(target, LERP_DRAG);
      clampInBounds(pos);
      resolveCollisionsFor(dragging, /*ignoreForSnap=*/false);
    }
    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();
      const current = dragging;
      const block = findBlock(current.group);
      if(!trySnapNeighbors(current, true)) trySnapGrid(current, true);
      if(block){
        block.userData = block.userData || {};
        block.userData.dragging = false;
        refreshBlockVisual(block);
      }
      dragging = null;
    }
    // ======== HUD / RENDER ===================================================
    const placedInfo = document.getElementById('placedInfo');
    const groupInfo  = document.getElementById('groupInfo');
    function updateHUD(){
      const nPlaced = entries.filter(e=>e.placed).length;
      placedInfo.textContent = `${nPlaced} placees`;
      const blk = dragging? findBlock(dragging.group) : null;
      const count = blk? countPieces(blk):1;
      groupInfo.textContent = `Bloc: ${count} piece${count>1?'s':''}`;
    }
    function countPieces(block){
      let c=0; for(const e of entries){ if(findBlock(e.group)===findBlock(block)) c++; }
      return c||1;
    }
    function render(){ requestAnimationFrame(render); updateHUD(); renderer.render(scene, camera); }
    // Inputs souris / tactile
    renderer.domElement.addEventListener('pointerdown', pointerDown, {passive:false});
    renderer.domElement.addEventListener('pointermove', pointerMove, {passive:false});
    window.addEventListener('pointerup', pointerUp, {passive:false});
    // Réinitialiser positions aléatoires de départ
    const scatterEntries = (spread = 0.3) => {
      for (const e of entries) {
        const currentRoot = findBlock(e.group);
        if (currentRoot.children.length > 1 || currentRoot.parent !== puzzleRoot) {
          const solo = reparentAsBlock(e.mesh, puzzleRoot);
          solo.userData = solo.userData || {};
          solo.userData.placed = false;
          solo.userData.locked = false;
          e.group = solo;
        } else if (currentRoot !== e.group) {
          e.group = currentRoot;
        }
        const jitter = new THREE.Vector3((Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread, 0);
        e.group.position.copy(e.target.clone().add(jitter));
        clampInBounds(e.group.position);
        e.group.position.z = 0;
        e.group.scale.set(1, 1, 1);
        setEntryPlaced(e, false);
      }
      for (const child of [...puzzleRoot.children]) {
        const stillUsed = entries.some(entry => findBlock(entry.group) === child);
        if (!stillUsed) {
          puzzleRoot.remove(child);
        }
      }
      updateHUD();
    };
    document.getElementById('resetBtn').addEventListener('click', ()=>{
      scatterEntries();
      showStatus('Distribution des pieces...', { hideAfter: 2000 });
    });
  </script>
</body>
</html>
